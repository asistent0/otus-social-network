# Тест чтения

1. Запросы на чтение `/user/search`, `/user/get/{id}`
2. Результат нагрузки до добавления slave представлены ниже в таблице.
3. Настроил 2 slave с потоковой передачей репликацией.
4. Настроил в проекте чтение с реплики. В Symfony это можно было сделать путем указания в конфигурационном файле реплик.
5. Результат нагрузки после добавления slave представлены ниже в таблице.

| Users  | Avg Latency (ms) | Throughput (req/sec) |
|--------|:----------------:|:--------------------:|
| Before |                  |                      |
| 100    |      26990       |         3.1          |
| After  |                  |                      |
| 100    |      23675       |         3.5          |

Видно, что после добавления двух реплик, запросы стали работать немного быстрее.

# Тест записи

6. Настроил кворумную синхронную репликацию `'FIRST 1 ("postgres-slave1", "postgres-slave2")'`.
7. Создал нагрузку на запись в течение минуты.
8. Примерно посередине работы теста второй slave был остановлен.
9. В результате теста было записано 238 строк. Ошибок при записи при этом не возникло.
10. Остановил macter. Запромоутил slave1 и настроил остальные реплики на работу с новым мастером. Запустил обе реплики.
11. Проверил наличие последних транзакций на slave2. Все 238 новых записей на месте.
12. Вернул master к мастеру и оставил кворумную синхронную репликацию.
